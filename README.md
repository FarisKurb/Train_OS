# Симуляция движения поездов по маршруту Душанбе — Гиссар — Регар — Пахтаабад

## Постановка задачи

Разработать простую многопоточную C++-программу, моделирующую движение минимум 8 поездов по ветке **Душанбе — Гиссар — Регар — Пахтаабад** с такими требованиями:

- Каждый поезд — отдельный поток, у каждого уникальный идентификатор.  
- На станции одновременно может находиться только один поезд (реализовано через общий `station_lock`).  
- Все события (движение, прибытие, стоянка, отправление, остановка) логируются в консоль с временными метками `HH:MM:SS`.  
- Время движения между станциями и время стоянки — случайные интервалы.  
- Симуляция выполняется до тех пор, пока пользователь не нажмёт Enter; после сигнала поезда завершают текущую итерацию и корректно останавливаются.

---

## Работа программы

1. Формируется маршрут как массив строк: `{"Dushanbe", "Gissar", "Regar", "Pakhtaabad"}`.  
2. Создаётся 8 объектов поездов, для каждого запускается поток `worker(Train*)`.  
3. Внутри потока поезд выполняет цикл:
   - логирование начала движения к текущей станции;
   - задержка (имитация пути);
   - захват глобального мьютекса `station_lock` (гарантия того, что в этот момент только один поезд находится на *любой* станции);
   - логирование прибытия;
   - задержка (имитация стоянки);
   - логирование отправления;
   - освобождение `station_lock`;
   - переход к следующей станции по кругу.
4. Главный поток ожидает нажатия Enter, затем ставит флаг `active = false` для всех поездов; потоки завершают цикл и выводят `STOPPED`, затем `join()` в главном потоке; освобождение ресурсов и завершение программы.

---

## Вывод программы (реальный фрагмент)
```console
[PRESS ENTER TO STOP...
[20:17:52] Train 1 MOVING TO Dushanbe
[20:17:52] Train 3 MOVING TO Dushanbe
[20:17:52] Train 4 MOVING TO Dushanbe
[20:17:52] Train 2 MOVING TO Dushanbe
[20:17:52] Train 5 MOVING TO Dushanbe
[20:17:52] Train 6 MOVING TO Dushanbe
[20:17:52] Train 7 MOVING TO Dushanbe
[20:17:52] Train 8 MOVING TO Dushanbe
[20:17:53] Train 4 ARRIVED at Dushanbe
[20:17:55] Train 4 LEAVING Dushanbe
[20:17:55] Train 4 MOVING TO Gissar
[20:17:55] Train 2 ARRIVED at Dushanbe
[20:17:56] Train 2 LEAVING Dushanbe
[20:17:56] Train 2 MOVING TO Gissar
[20:17:56] Train 8 ARRIVED at Dushanbe
[20:17:58] Train 8 LEAVING Dushanbe
[20:17:58] Train 8 MOVING TO Gissar
[20:17:58] Train 5 ARRIVED at Dushanbe
[20:17:59] Train 5 LEAVING Dushanbe
[20:17:59] Train 5 MOVING TO Gissar
[20:17:59] Train 7 ARRIVED at Dushanbe
[20:18:01] Train 7 LEAVING Dushanbe
[20:18:01] Train 7 MOVING TO Gissar
[20:18:01] Train 3 ARRIVED at Dushanbe
[20:18:02] Train 3 LEAVING Dushanbe
[20:18:02] Train 3 MOVING TO Gissar
[20:18:02] Train 1 ARRIVED at Dushanbe
[20:18:03] Train 1 LEAVING Dushanbe
[20:18:03] Train 1 MOVING TO Gissar
[20:18:03] Train 6 ARRIVED at Dushanbe
[20:18:05] Train 6 LEAVING Dushanbe
[20:18:05] Train 6 MOVING TO Gissar
[20:18:05] Train 4 ARRIVED at Gissar
[20:18:06] Train 4 LEAVING Gissar
[20:18:06] Train 4 MOVING TO Regar
[20:18:06] Train 2 ARRIVED at Gissar
[20:18:08] Train 2 LEAVING Gissar
[20:18:08] Train 2 MOVING TO Regar
[20:18:08] Train 8 ARRIVED at Gissar
[20:18:09] Train 8 LEAVING Gissar
[20:18:09] Train 8 MOVING TO Regar
[20:18:09] Train 5 ARRIVED at Gissar
[20:18:11] Train 5 LEAVING Gissar
[20:18:11] Train 5 MOVING TO Regar
[20:18:11] Train 7 ARRIVED at Gissar
[20:18:12] Train 7 LEAVING Gissar
[20:18:12] Train 7 MOVING TO Regar
[20:18:12] Train 3 ARRIVED at Gissar
[20:18:14] Train 3 LEAVING Gissar
[20:18:14] Train 3 MOVING TO Regar
[20:18:14] Train 1 ARRIVED at Gissar
[20:18:15] Train 1 LEAVING Gissar
[20:18:15] Train 1 MOVING TO Regar
[20:18:15] Train 6 ARRIVED at Gissar
[20:18:17] Train 6 LEAVING Gissar
[20:18:17] Train 6 MOVING TO Regar
[20:18:17] Train 4 ARRIVED at Regar
[20:18:19] Train 4 LEAVING Regar
[20:18:19] Train 4 MOVING TO Pakhtaabad
[20:18:19] Train 2 ARRIVED at Regar
[20:18:20] Train 2 LEAVING Regar
[20:18:20] Train 2 MOVING TO Pakhtaabad
[20:18:20] Train 8 ARRIVED at Regar
[20:18:22] Train 8 LEAVING Regar
[20:18:22] Train 8 MOVING TO Pakhtaabad
[20:18:22] Train 5 ARRIVED at Regar
[20:18:24] Train 5 LEAVING Regar
[20:18:24] Train 5 MOVING TO Pakhtaabad
[20:18:24] Train 7 ARRIVED at Regar
[20:18:25] Train 7 LEAVING Regar
[20:18:25] Train 7 MOVING TO Pakhtaabad
[20:18:25] Train 3 ARRIVED at Regar
[20:18:27] Train 3 LEAVING Regar
[20:18:27] Train 3 MOVING TO Pakhtaabad
[20:18:27] Train 1 ARRIVED at Regar

[20:18:29] Train 1 LEAVING Regar
[20:18:29] Train 1 STOPPED
[20:18:29] Train 6 ARRIVED at Regar
[20:18:31] Train 6 LEAVING Regar
[20:18:31] Train 6 STOPPED
[20:18:31] Train 4 ARRIVED at Pakhtaabad
[20:18:32] Train 4 LEAVING Pakhtaabad
[20:18:32] Train 4 STOPPED
[20:18:32] Train 2 ARRIVED at Pakhtaabad
[20:18:33] Train 2 LEAVING Pakhtaabad
[20:18:33] Train 2 STOPPED
[20:18:33] Train 8 ARRIVED at Pakhtaabad
[20:18:35] Train 8 LEAVING Pakhtaabad
[20:18:35] Train 8 STOPPED
[20:18:35] Train 5 ARRIVED at Pakhtaabad
[20:18:36] Train 5 LEAVING Pakhtaabad
[20:18:36] Train 5 STOPPED
[20:18:36] Train 7 ARRIVED at Pakhtaabad
[20:18:37] Train 7 LEAVING Pakhtaabad
[20:18:37] Train 7 STOPPED
[20:18:37] Train 3 ARRIVED at Pakhtaabad
[20:18:39] Train 3 LEAVING Pakhtaabad
[20:18:39] Train 3 STOPPED
Simulation finished!
```

---


---

## Анализ вывода (подробный)

### 1. Порядок старта и начальная конкуренция
- В начале все поезда стартуют почти одновременно (время `20:17:52`), видно массовые сообщения `MOVING TO Dushanbe`.  
- Одновременный старт порождает конкуренцию за глобальный `station_lock`: первый поезд, который захватил mutex, получает право зайти на станцию первым; остальные ждут своей очереди.  

### 2. Последовательность прибытий и отпуска
- Для станции **Dushanbe** видим порядок прихода и отправления: `Train 4` оказался первым (ARRIVED 20:17:53 → LEAVING 20:17:55 → MOVING TO Gissar 20:17:55), затем пошли `2`, `8`, `5`, `7`, `3`, `1`, `6`.  
- Аналогичный поэтапный порядок наблюдается для **Gissar** и **Regar**: те же поезда идут по схеме один за другим.  
- Это ожидаемо: глобальный `station_lock` последовательно даёт доступ одному поезду в любой момент времени.

### 3. Временные интервалы (наблюдаемые)
- Примеры интервалов по логам:
  - Dwell (время стоянки) у `Train 4` на Dushanbe: 20:17:53 → 20:17:55 ≈ 2 с.
  - Travel `Dushanbe → Gissar` для `Train 4`: MOVING 20:17:55 → ARRIVED Gissar 20:18:05 ≈ 10 с.
  - Dwell/Travel у других поездов похожи, но варьируются.  
- Вывод: интервалы в логе отражают рандомные задержки в программе; их распределение может отличаться от ожидаемого диапазона из кода (если код изменялся, реальные интервалы показывают фактическое поведение).

### 4. Поведение при остановке симуляции
- После нажатия Enter главный поток выставил флаг остановки. Поезда завершают текущую итерацию (прибытие/отправление) и выводят `STOPPED`.
- В логах видно, что некоторые поезда (`1`, `6`) остановились раньше прочих — это зависит от того, где именно они находились в момент сигнала: те, кто были ближе к завершению итерации, завершили быстрее.
- Все потоки успешно завершились — `Simulation finished!`.

### 5. Влияние глобального `station_lock`
- В текущей реализации **один общий `station_lock`** означает, что в любой момент **всей симуляции только один поезд** может находиться на любой станции — это сильная сериализация:
  - положительный эффект: простая корректная синхронизация, отсутствуют гонки между платформами;
  - отрицательный эффект: искусственное снижение параллелизма — поезда не могут одновременно стоять на разных станциях, хотя в реальной сети это возможно.
- В логах это видно по строго последовательным `ARRIVED`/`LEAVING` событиям: нет параллельных ARRIVED на разных станциях.

### 6. Выявленные потенциальные проблемы и замечания
- Флаг `active` у `Train` в коде — обычный `bool` без синхронизации. Чтение/запись такого флага из разных потоков — потенциальная гонка данных (undefined behavior). Рекомендация: использовать `std::atomic<bool>` или защищать доступ mutex'ом.
- `station_lock.lock()` / `unlock()` используются вручную. Лучше применять RAII (`std::lock_guard<std::mutex>`) для исключения риска пропуска `unlock()` в случае исключений.
- Сейчас каждая платформа/станция не имеет собственной блокировки, поэтому нельзя моделировать две отдельные платформы (north/south). Чтобы моделировать две платформы — нужен mutex (или семафор) на каждую платформу или на каждую станцию по отдельности.
- Формат времени в секундах достаточен для логов, но для более точного анализа полезно добавлять миллисекунды.
- В коде используется динамическое выделение `new Train()` и ручное `delete`. Упрощение: использовать `vector<Train>` и передавать указатели/индексы на элементы в векторе, чтобы избежать ручного управления памятью.

### 7. Что можно измерить дополнительно (для углублённого анализа)
- **Среднее время ожидания** перед тем, как поезд получает доступ к `station_lock` (ожидание в очереди).  
- **Средняя длительность стоянки** на каждой станции.  
- **Средняя длительность движения** между конкретными парами станций.  
- **Загрузка mutex'а**: сколько времени в секунду `station_lock` был занят (процент занятости).  
- Для сбора статистики можно добавлять сбор времён (вектор времён) и выводить агрегаты по завершении.

### 8. Интерпретация логов по безопасности и корректности
- В логах нет пересечений `ARRIVED` для одной и той же станции в один и тот же момент, значит взаимная эксклюзивность обеспечена.  
- Нет признаков deadlock (зависших потоков): все поезда завершили работу после сигнала остановки.  
- Очередность прибытия определяется случайными задержками и порядком захвата `station_lock`.

---

## Заключение

- Программа демонстрирует корректную, простую реализацию синхронизации доступа к станции через один общий `station_lock`.  
- Лог с временными метками наглядно показывает поведение системы: старт всех поездов, последовательное обслуживание каждой станции, и корректное завершение по нажатию Enter.  
- Основной узкий момент текущей реализации — чрезмерная сериализация работы поездов (из-за одного глобального `station_lock`), что существенно ограничивает параллелизм и реалистичность.  


